#pragma once

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include "tools/variant.h"
#include "tools/utils.h"

namespace toolkit{

template<typename key, typename variant>
class mIniBasic : public std::map<key, variant> {
public:

    // 解析字符串，类似ini配置解析为 "http.port" "8080"
    void parse(const std::string &text){
        (*this).clear();
        
        // 拆分
        std::vector<std::string> lines = tokenize(text, "\n");
        std::string symbol, tag;
        for(auto &line : lines) {
            line = trim(line);

            // 忽略空行或注释行
            if(line.empty() || line.front() == ';' || line.front() == '#'){
                continue;
            }
            if(line.size() >=3 && line.front()=='[' && line.back()==']'){
                tag = trim(line.substr(1, line.size() - 2));
            }else{
                
                auto at = line.find('=');
                
                symbol = trim(tag + "." + line.substr(0, at));
                (*this)[symbol] = (at==std::string::npos ? std::string() : trim(line.substr(at+1)));
            }

        }
    }

    // 打印
    std::string dump(const std::string &header = ";auto-generated by mINI class {", const std::string &footer=";} ---") const {
        std::string front(header + (header.empty()?"":"\r\n")), output, tag;
        std::vector<std::string> kv;

        for(auto &pr : *this){
            // 解析 key
            auto pos = pr.first.find('.');
            if(pos!=std::string::npos) {
                kv = {pr.first.substr(0, pos), pr.first.substr(pos+1)};
            }else{
                kv = {"", pr.first};
            }

            // 如果没有 tag （对应配置中的[xxx]）直接输出
            if(kv[0].empty()){
                front += kv[1] + "=" + pr.second + "\r\n";
                continue;
            }

            // 如果 tag 和当前的不一样，则输出 [xxx]
            if(tag != kv[0]) {
                output += "\r\n[" + (tag=kv[0]) + "]\r\n";
            }

            // 输出 k v
            output += kv[1] + "=" + pr.second + "\r\n";
        }

        return front + output + "\r\n" + footer + (footer.empty()?"":"\r\n");
    }
        
  
    // 解析 ini 文件
    void parseFile(const std::string &fileName = exePath() + ".ini") {
        std::ifstream in(fileName, std::ios::in | std::ios::binary | std::ios::ate);
        if(!in.good()){
            throw std::invalid_argument("Invalid ini file: " + fileName);
        }
        auto size = in.tellg();
        in.seekg(0, std::ios::beg);
        std::string buf;
        buf.resize(size);
        in.read((char *)buf.data(), size);
        parse(buf);
    }

    // 输出到文件
    void dumpFile(const std::string &fileName = exePath() + ".ini") {
        std::ofstream out(fileName, std::ios::out | std::ios::binary | std::ios::trunc);
        auto dmp = dump();
        out.write(dmp.data(), dmp.size());
    }

    static mIniBasic &Instance();

private:
    // 使用 chars 分割字符串
    std::vector<std::string> tokenize(const std::string &self, const std::string &chars) const {
        std::vector<std::string> tokens(1);
        std::string map(256, '\0');
        for(char ch : chars){
            map[(uint8_t)ch] = '\1';
        }

        for (char ch:self){
            if(!map.at((uint8_t) ch)) {
                tokens.back().push_back(ch);
            }else if (!tokens.back().empty()) {
                tokens.push_back(std::string());
            }
        }
        while (!tokens.empty() && tokens.back().empty()){
            tokens.pop_back();
        }
        return tokens;
    }

};


using mINI = mIniBasic<std::string, variant>;

}